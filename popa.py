# -*- coding: utf-8 -*-
"""popa.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fMziXRz07UvYjfmqo20LUvGex_yq--dU
"""

from collections import defaultdict, deque
import itertools
# Domain (grounded actions)
class Action:
    def __init__(self, name, preconds=None, adds=None, dels=None):
        self.name = name
        self.pre = set(preconds or [])
        self.add = set(adds or [])
        self.del_effects = set(dels or [])
    def __repr__(self):
        return f"Action({self.name})"
# Example: robot moves an object from R1 to R2
ACTIONS = [
    Action("PickUp@R1",
           preconds=["RobotAt(R1)", "ObjAt(R1)", "HandsFree"],
           adds=["Holding(O)"], dels=["ObjAt(R1)", "HandsFree"]),
    Action("PutDown@R2",
           preconds=["Holding(O)", "RobotAt(R2)"],
           adds=["ObjAt(R2)", "HandsFree"], dels=["Holding(O)"]),
    Action("Move@R1->R2",
           preconds=["RobotAt(R1)"],
           adds=["RobotAt(R2)"], dels=["RobotAt(R1)"]),
    Action("Move@R2->R1",
           preconds=["RobotAt(R2)"],
           adds=["RobotAt(R1)"], dels=["RobotAt(R2)"]),
]
INITIAL = set(["RobotAt(R1)", "ObjAt(R1)", "HandsFree"])
GOALS = set(["RobotAt(R2)", "ObjAt(R2)"])
# POP Plan Representation
class POPPlan:
    def __init__(self):
        self.steps = {} # id -> Action (Action objects for Init/Goal too)
        self.next_id = 0
        self.orderings = set() # (before_id, after_id)
        self.causal_links = [] # list of (provider_id, literal, consumer_id)
        self.open_preconds = [] # list of (consumer_id, literal)
    def new_step(self, action):
        sid = self.next_id
        self.steps[sid] = action
        self.next_id += 1
        return sid
    def add_ordering(self, a, b):
        self.orderings.add((a, b))
    def add_causal_link(self, provider, lit, consumer):
        self.causal_links.append((provider, lit, consumer))
    def copy(self):
        p = POPPlan()
        p.steps = dict(self.steps)
        p.next_id = self.next_id
        p.orderings = set(self.orderings)
        p.causal_links = list(self.causal_links)
        p.open_preconds = list(self.open_preconds)
        return p
    def __repr__(self):
        s = ["POPPlan:"]
        for sid, act in sorted(self.steps.items()):
            s.append(f" {sid}: {act.name}")
        s.append(" Orderings: " + str(self.orderings))
        s.append(" Causal links: " + str(self.causal_links))
        s.append(" Open preconds: " + str(self.open_preconds))
        return "\n".join(s)
# Utility functions
def negate(lit):
    return lit[4:] if lit.startswith("not ") else "not " + lit
def literal_negation_exists(action, lit):
    # check if an action produces the negation of lit (either as add or del)
    return negate(lit) in action.add or negate(lit) in action.del_effects
def occurs_in_effects(action, lit):
    return lit in action.add
def topo_sort_ids(steps_ids, orderings):
    # Kahn's algorithm for topological sort; returns one topological order or None if cycle
    incoming = {s: 0 for s in steps_ids}
    adj = defaultdict(list)
    for a, b in orderings:
        if a in incoming and b in incoming:
            incoming[b] += 1
        adj[a].append(b)
    q = deque([s for s, c in incoming.items() if c == 0])
    order = []
    while q:
        n = q.popleft()
        order.append(n)
        for nb in adj[n]:
            incoming[nb] -= 1
            if incoming[nb] == 0:
                q.append(nb)
    if len(order) != len(steps_ids):
        return None
    return order
def all_topo_sorts(steps_ids, orderings):
    # Enumerate all topological sorts consistent with 'orderings' (backtracking).
    adj = defaultdict(list)
    indeg = {s: 0 for s in steps_ids}
    for a, b in orderings:
        if a in indeg and b in indeg:
            adj[a].append(b)
            indeg[b] += 1
    results = []
    def backtrack(path, indeg_local):
        if len(path) == len(steps_ids):
            results.append(list(path))
            return
        available = [n for n in steps_ids if indeg_local[n] == 0 and n not in path]
        for s in sorted(available):
            new_indeg = indeg_local.copy()
            new_indeg[s] = -1
            for nb in adj[s]:
                new_indeg[nb] -= 1
            path.append(s)
            backtrack(path, new_indeg)
            path.pop()
    backtrack([], indeg)
    return results
# Planner: initialization
def init_plan():
    plan = POPPlan()
    init = Action("Init", preconds=[], adds=list(INITIAL), dels=[])
    goal = Action("Goal", preconds=list(GOALS), adds=[], dels=[])
    id_init = plan.new_step(init)
    id_goal = plan.new_step(goal)
    plan.add_ordering(id_init, id_goal)
    for g in GOALS:
        plan.open_preconds.append((id_goal, g))
    return plan, id_init, id_goal
# Threat detection / helpers
def is_threat(plan, threat_id, provider_id, consumer_id, lit):
    threat_action = plan.steps[threat_id]
    if not literal_negation_exists(threat_action, lit):
        return False
    # If threat is ordered before provider => safe; If threat after consumer => safe
    if (threat_id, provider_id) in plan.orderings:
        return False
    if (consumer_id, threat_id) in plan.orderings:
        return False
    if threat_id in (provider_id, consumer_id):
        return False
    return True
def find_achievers(plan, lit):
    return [sid for sid, act in plan.steps.items() if occurs_in_effects(act, lit)]
def consistent_no_cycle(plan):
    ids = list(plan.steps.keys())
    return topo_sort_ids(ids, plan.orderings) is not None
# Backtracking POP algorithm
def POP_backtrack(plan, all_actions, depth=0, max_depth=300):
    if depth > max_depth:
        return None
    if not plan.open_preconds:
        return plan
    consumer_id, lit = plan.open_preconds.pop(0)
    # Candidate providers: existing achievers + options to add a new action from domain
    candidates = find_achievers(plan, lit)
    for a in all_actions:
        if lit in a.add:
            # only add new action instance if not already existing with the same name
            existing_same = [sid for sid, act in plan.steps.items() if isinstance(act, Action) and
                             act.name == a.name]
            if not existing_same:
                candidates.append(("new", a))
            else:
                candidates.extend(existing_same)
    for cand in candidates:
        new_plan = plan.copy()
        # add chosen provider (either new or existing)
        if isinstance(cand, tuple) and cand[0] == "new":
            act = cand[1]
            sid = new_plan.new_step(act)
        else:
            sid = cand
        # ordering: provider before consumer
        new_plan.add_ordering(sid, consumer_id)
        # causal link
        new_plan.add_causal_link(sid, lit, consumer_id)
        # add the provider's preconditions as open preconditions to be satisfied
        act_obj = new_plan.steps[sid]
        for p in act_obj.pre:
            new_plan.open_preconds.append((sid, p))
        # threat detection
        threats = [t for t in new_plan.steps if is_threat(new_plan, t, sid, consumer_id, lit)]
        if not threats:
            if consistent_no_cycle(new_plan):
                res = POP_backtrack(new_plan, all_actions, depth+1, max_depth)
                if res:
                    return res
            continue
        # Try to resolve threats by ordering threat before provider or after consumer (backtracking)
        def try_resolve_threats(plan_with_threats, threats_list, idx=0):
            if idx >= len(threats_list):
                if not consistent_no_cycle(plan_with_threats):
                    return None
                return POP_backtrack(plan_with_threats, all_actions, depth+1, max_depth)
            t = threats_list[idx]
            # strategy 1: t before provider (t -> provider)
            p1 = plan_with_threats.copy()
            p1.add_ordering(t, sid)
            if consistent_no_cycle(p1):
                r = try_resolve_threats(p1, threats_list, idx+1)
                if r:
                    return r
            # strategy 2: consumer before t (consumer -> t)
            p2 = plan_with_threats.copy()
            p2.add_ordering(consumer_id, t)
            if consistent_no_cycle(p2):
                r = try_resolve_threats(p2, threats_list, idx+1)
                if r:
                    return r
            return None
        res = try_resolve_threats(new_plan, threats, 0)
        if res:
            return res
    # nothing worked; put the open precondition back and backtrack
    plan.open_preconds.insert(0, (consumer_id, lit))
    return None
# Linearization & Simulation
def simulate_linearization(order, plan):
    state = set(INITIAL)
    for sid in order:
        act = plan.steps[sid]
        if act.name == "Init":
            continue
        if act.name == "Goal":
            return GOALS.issubset(state)
        # check preconditions
        if not act.pre.issubset(state):
            return False
        state -= set(act.del_effects)
        state |= set(act.add)
    return GOALS.issubset(state)
# Demo / main
def main():
    plan0, id_init, id_goal = init_plan()
    print("Running POP search...")
    result_plan = POP_backtrack(plan0, ACTIONS)
    if not result_plan:
        print("No partial-order plan found.")
        return
    print("\nPartial-order plan discovered:")
    print(result_plan)
    # enumerate all topological linearizations consistent with orderings
    ids = list(result_plan.steps.keys())
    topo_orders = all_topo_sorts(ids, result_plan.orderings)
    print(f"\nNumber of linearizations to test: {len(topo_orders)}")
    valid_orders = []
    for ord_ in topo_orders:
        if simulate_linearization(ord_, result_plan):
            valid_orders.append(ord_)
    if valid_orders:
        print("\nValid linearization(s) that satisfy preconditions and goals found:")
        for vo in valid_orders:
            print(" -> ".join(f"{i}:{result_plan.steps[i].name}" for i in vo))
    else:
        print("\nNo valid linearization found among topological sorts.")
    # attempt to enforce causal-link provider->consumer orderings and re-check
    enforced = result_plan.copy()
    for provider, lit, consumer in enforced.causal_links:
        enforced.add_ordering(provider, consumer)
    topo2 = all_topo_sorts(list(enforced.steps.keys()), enforced.orderings)
    print(f"After enforcing causal-link orderings, linearizations: {len(topo2)}")
    found = []
    for ord_ in topo2:
        if simulate_linearization(ord_, enforced):
            found.append(ord_)
    if found:
        print("Valid after enforcing causal-link orderings:")
        for vo in found:
            print(" -> ".join(f"{i}:{enforced.steps[i].name}" for i in vo))
    else:
        print("Still no valid linearization. The partial-order may need stronger ordering constraints or a different provider choice.")
if __name__ == "__main__":
    main()

