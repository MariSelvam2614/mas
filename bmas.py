# -*- coding: utf-8 -*-
"""bmas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KL8slMdW_i4uJwR6cApWJNZ0t1SqaSnh
"""

import time

class Agent:
    def __init__(self, name, start_pos, box_pos, goal_pos):
        self.name = name
        self.position = start_pos
        self.box_position = box_pos
        self.goal_position = goal_pos
        self.has_box = False

    def next_move(self):
        target = self.box_position if not self.has_box else self.goal_position
        current_x, current_y = self.position
        target_x, target_y = target

        if current_x < target_x:
            return (current_x + 1, current_y)
        elif current_x > target_x:
            return (current_x - 1, current_y)
        elif current_y < target_y:
            return (current_x, current_y + 1)
        elif current_y > target_y:
            return (current_x, current_y - 1)
        else:
            # Already at target
            return (current_x, current_y)

def print_grid(agent1, agent2):
    size = 5
    grid = [["." for _ in range(size)] for _ in range(size)]

    # Mark goals
    gx1, gy1 = agent1.goal_position
    gx2, gy2 = agent2.goal_position
    grid[gy1][gx1] = "G1"
    grid[gy2][gx2] = "G2"

    # Mark boxes if not carried
    if not agent1.has_box:
        bx1, by1 = agent1.box_position
        grid[by1][bx1] = "B1"
    if not agent2.has_box:
        bx2, by2 = agent2.box_position
        grid[by2][bx2] = "B2"

    # Mark agents (if carrying box, show combined)
    ax1, ay1 = agent1.position
    if agent1.has_box:
        grid[ay1][ax1] = "A1B"
    else:
        grid[ay1][ax1] = "A1"

    ax2, ay2 = agent2.position
    if agent2.has_box:
        if grid[ay2][ax2] == "A1B":
            grid[ay2][ax2] = "A1B/A2B"  # rare overlap
        else:
            grid[ay2][ax2] = "A2B"
    else:
        if grid[ay2][ax2] in ["A1", "A1B"]:
            grid[ay2][ax2] = "A1/A2"  # rare overlap
        else:
            grid[ay2][ax2] = "A2"

    # Print the grid row-wise, y=0 top row
    for y in range(size):
        row = []
        for x in range(size):
            row.append(f"{grid[y][x]:<4}")
        print(" ".join(row))
    print("------------------------------")


def simulate():
    # Agents initialized with distinct positions and goals to avoid overlapping paths
    agent1 = Agent("AgentA", (0, 0), (1, 0), (1, 4))
    agent2 = Agent("AgentB", (4, 4), (3, 4), (3, 0))

    print(" Starting Multi-Agent Box Moving Simulation with Separate Paths...\n")
    print(f"{agent1.name} at {agent1.position}, box at {agent1.box_position}, goal at {agent1.goal_position}")
    print(f"{agent2.name} at {agent2.position}, box at {agent2.box_position}, goal at {agent2.goal_position}")
    print("------------------------------\n")

    max_steps = 50
    task1_done = False
    task2_done = False

    for step in range(max_steps):
        print(f" Step {step + 1}")
        print_grid(agent1, agent2)

        # Agents pick up box if on box position and not carrying
        if not agent1.has_box and agent1.position == agent1.box_position:
            agent1.has_box = True
            print(f" {agent1.name} picked up box at {agent1.box_position}")
        if not agent2.has_box and agent2.position == agent2.box_position:
            agent2.has_box = True
            print(f" {agent2.name} picked up box at {agent2.box_position}")

        # Calculate next moves
        next_move_1 = agent1.next_move() if not task1_done else agent1.position
        next_move_2 = agent2.next_move() if not task2_done else agent2.position

        # Check conflict: prevent agents from moving into the same cell or swapping places
        conflict = False
        if next_move_1 == next_move_2:
            conflict = True
        elif next_move_1 == agent2.position and next_move_2 == agent1.position:
            conflict = True

        if conflict:
            print(" Conflict detected: Both agents wait to avoid collision.")
        else:
            # Move AgentA if not done and move is different
            if not task1_done and next_move_1 != agent1.position:
                print(f" {agent1.name} moves from {agent1.position} to {next_move_1}")
                agent1.position = next_move_1
                if agent1.has_box:
                    agent1.box_position = next_move_1
            else:
                if not task1_done:
                    print(f" {agent1.name} waits at {agent1.position}")

            # Move AgentB if not done and move is different
            if not task2_done and next_move_2 != agent2.position:
                print(f" {agent2.name} moves from {agent2.position} to {next_move_2}")
                agent2.position = next_move_2
                if agent2.has_box:
                    agent2.box_position = next_move_2
            else:
                if not task2_done:
                    print(f" {agent2.name} waits at {agent2.position}")


        # After move, check if delivered (agent standing on goal with box)
        if agent1.position == agent1.goal_position and agent1.has_box and not task1_done:
            print(f" {agent1.name} delivered box to {agent1.goal_position}")
            task1_done = True

        if agent2.position == agent2.goal_position and agent2.has_box and not task2_done:
            print(f" {agent2.name} delivered box to {agent2.goal_position}")
            task2_done = True

        # Print grid after move and possible delivery
        print_grid(agent1, agent2)


        if task1_done and task2_done:
            print("\nâœ… All tasks completed! Boxes delivered.")
            break

        time.sleep(0.5)

if __name__ == "__main__":
    simulate()

