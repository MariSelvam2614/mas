# -*- coding: utf-8 -*-
"""maze.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ili3CDFiOQcmfZiiYT_OQ2az2RYmiT6R
"""

import matplotlib.pyplot as plt
import numpy as np
import time
import random
from IPython.display import display, clear_output
# Maze Definition
# 0 - empty, 1 - wall, 2 - item
maze = [
[0, 1, 0, 0, 2],
[0, 0, 1, 0, 0],
[1, 0, 0, 1, 2],
[0, 2, 0, 0, 0],
[0, 1, 0, 1, 0]
]
rows = len(maze)
cols = len(maze[0])
# Starting position of the agent
agent_pos = [0, 0]
# Define goal position
goal_pos = (rows - 1, cols - 1)
# Matplotlib Setup
fig, ax = plt.subplots(figsize=(cols, rows))
# Draw Maze
def draw_maze():
    clear_output(wait=True) # Clear the previous plot
    ax.clear()
    # Use numpy array for better plotting with imshow
    maze_np = np.array(maze)
    # Visualize the maze (0: empty, 1: wall, 2: item)
    # Use a colormap to differentiate
    cmap = plt.cm.viridis # You can choose other colormaps
    ax.imshow(maze_np, cmap=cmap, origin='upper')
    # Mark walls
    for r in range(rows):
        for c in range(cols):
            if maze_np[r, c] == 1:
                ax.add_patch(plt.Rectangle((c - 0.5, r - 0.5), 1, 1, color='black'))
    # Mark items
    item_rows, item_cols = np.where(maze_np == 2)
    ax.plot(item_cols, item_rows, 'o', color='gold', markersize=15, label='Item')
    # Mark agent
    ar, ac = agent_pos
    ax.plot(ac, ar, 'o', color='blue', markersize=20, label='Agent')
    # Mark goal
    gr, gc = goal_pos
    ax.plot(gc, gr, '*', color='red', markersize=25, label='Goal')
    ax.set_xticks(np.arange(cols))
    ax.set_yticks(np.arange(rows))
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.grid(True, which='both', color='black', linewidth=0.5)
    ax.set_title("Agent Maze Navigation")
    ax.legend()
    display(fig)
# Move Agent Function
def move_agent():
    global agent_pos, maze
    items_remaining = sum(row.count(2) for row in maze)
    if items_remaining > 0:
        # Random movement if items remain
        directions = [(0,1), (1,0), (0,-1), (-1,0)]
        random.shuffle(directions)
        for dr, dc in directions:
            nr, nc = agent_pos[0] + dr, agent_pos[1] + dc
            if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] != 1:
                agent_pos = [nr, nc]
                # Collect item if present
                if maze[nr][nc] == 2:
                    maze[nr][nc] = 0
                    print(f"âœ… Item collected at ({nr}, {nc})")
                draw_maze()
                time.sleep(0.1) # Reduce sleep for faster simulation
                return # move once per tick
    else:
        # Move towards goal if no items remain
        gr, gc = goal_pos
        ar, ac = agent_pos
        # Prioritize movement along one axis
        if ar < gr and 0 <= ar + 1 < rows and maze[ar + 1][ac] != 1:
            agent_pos[0] += 1
        elif ar > gr and 0 <= ar - 1 < rows and maze[ar - 1][ac] != 1:
            agent_pos[0] -= 1
        elif ac < gc and 0 <= ac + 1 < cols and maze[ar][ac + 1] != 1:
            agent_pos[1] += 1
        elif ac > gc and 0 <= ac - 1 < cols and maze[ar][ac - 1] != 1:
            agent_pos[1] -= 1
        # If cannot move in prioritized direction due to wall/boundary, try other axis
        elif ar < gr and (ar + 1 >= rows or maze[ar + 1][ac] == 1):
            if ac < gc and 0 <= ac + 1 < cols and maze[ar][ac + 1] != 1:
                agent_pos[1] += 1
            elif ac > gc and 0 <= ac - 1 < cols and maze[ar][ac - 1] != 1:
                agent_pos[1] -= 1
        elif ar > gr and (ar - 1 < 0 or maze[ar - 1][ac] == 1):
            if ac < gc and 0 <= ac + 1 < cols and maze[ar][ac + 1] != 1:
                agent_pos[1] += 1
            elif ac > gc and 0 <= ac - 1 < cols and maze[ar][ac - 1] != 1:
                agent_pos[1] -= 1
        elif ac < gc and (ac + 1 >= cols or maze[ar][ac + 1] == 1):
            if ar < gr and 0 <= ar + 1 < rows and maze[ar + 1][ac] != 1:
                agent_pos[0] += 1
            elif ar > gr and 0 <= ar - 1 < rows and maze[ar - 1][ac] != 1:
                agent_pos[0] -= 1
        elif ac > gc and (ac - 1 < 0 or maze[ar][ac - 1] == 1):
            if ar < gr and 0 <= ar + 1 < rows and maze[ar + 1][ac] != 1:
                agent_pos[0] += 1
            elif ar > gr and 0 <= ar - 1 < rows and maze[ar - 1][ac] != 1:
                agent_pos[0] -= 1
    print(f" Agent moves towards goal: {agent_pos}")
    draw_maze()
    time.sleep(0.1) # Reduce sleep for faster simulation
# Main Simulation Loop
def run_simulation():
    global agent_pos, maze
    draw_maze()
    # Loop until the agent reaches the goal
    while agent_pos != list(goal_pos): # Convert tuple to list for comparison
        move_agent()
        # Check if the agent has reached the goal
        if agent_pos == list(goal_pos):
            print(" Agent reached the goal!")
            # Keep the final display
            ax.text(cols//2, rows//2, "Agent Reached Goal!", ha='center', va='center',
                    color='green', fontsize=20, weight='bold')
            display(fig)
            break # Break the loop when the goal is reached
# Start Simulation
run_simulation()

